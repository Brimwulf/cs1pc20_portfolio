cd's into the home directory
cd's into portfolio :3
makes a directory and calls it week3
makes a directory called greeting in week3
Then cd's into that directory.
Creates a git branch called greeting
Switches to the git branch
This step wanted me to create a file called greeting.c and then write the code into the file. To do this, I typed "touch greeting.c" to create the file. Then I typed "nano greeting.c" to edit the file and type out the code, after which I pressed ctrl+o to write out the text and then exited nano. Then to check that the file contained the text I typed I typed in cat greeting.c and thankfully it had what I just typed. This made me feel quite intelligent and I hope that feeling lasts.
I didn't intially know what this command did so I did some research. In order to understand it, I broke it down into individual parts. To start, gcc refers to the gcc compiler which is a set of compilers supporting various languages but specifically in this case it is going to allow us to compile the C code I just wrote. The -Wall flag is passed into the gcc command to specify certain settings as it compiles the code. Specifically, -Wall enables warnings to be given with any code written, in case there is errors. -pedantic is an option that checks that the code adheres to the ANSI C standard. What does that mean? It checks that the code follows standard syntax and semantics for the code written. The -c stops the compilation before it creates an executable file, this is because of the next part of this command. We want the computer to compile the source code file "greeting.c" and create an object file with the same name (but with a .o instead). An object file contains machine code or assembly code but isn't a complete program. This way, things such as variables and functions remain unresolved which is useful because we can link these object files together when we create an executable file. Lastly the -o greeting.o part of the command specifies the output of the command and generates a file called "greeting.o" I got a little curious and typed in cat greeting.o because I was interested to see what was in the file... this turned out to be a bit of a mistake because it returned a bunch of corrupt text and the text I typed in looked equally corrupt. Naturally my first instinct was to turn the machine off and on but I would be interested to look in to why this happened at a later stage. (EDIT: I found out the reason why the code was "corrupted" was because the contents of the file being concatinated was a binary file which the terminal tried to turn into text which is not meaningful to humans.)
NOTE: From line 10 to the next time I bring this up, Everything I write will be retroactive, meaning I have already executed these commands and are commenting on them after the fact. This is because the first time I wrote my predictions for what each command does, the file did not save and I lost my work. So instead I will just explain what each line does.
This code tests whether the function in greeting.c executed successfully and thus returned the value 0. It uses "assert" to check whether greet() (i.e. the function) has the value 0 and if it does the main function returns 0 (otherwise it returns an error). It's important to note that in the header for this file our greeting.h file is surrounded by quotes because it is our own header file.
Here we're creating the actual header file which is included in test_result.c.
This command appends the contents of the file greeting.o into the .gitignore file.
Doing the same here but with the libgreet.a file.
This command is used to manage an archive file, and the rv specifies that we want to add the file mentioned and the v for "verbose" means we want the terminal to tell us what it's doing exactly. We're adding to libgreet.a the file greeting.o
This command is using the gcc compiler to compile our test_result.c code. It has a few flags so I'll go through them one by one. Firstly the -o file specifies the output filename. We want the output file to be called test1.o. The -L flag specifies where the linker (which is the thing that "links" our object files together in a library so that they can use the modules called in the header files.) should look for libraries as it's compiling the code and the addition of the "." specifies it should look in the current working directory. The -lgreet flag is specifying that we want it to link to a library we're creating called libgreet.a (the gcc compiler ignores the "lib" part of the file and changes it to just l and vice versa). And lastly the -I. flag is specifying where to look for header files and in this case within the current directory because of the ".".
This command executes the test1 file. It output "Hello World!" into the command line so the code compiled and executed successfully.
The next three lines, add the changes to git, commits the changes and then pushes them to the CSgitlab project.
Switching to the master branch
Creating a new branch called vectors
And switching to the new branch
Switching to the directory week3
making a directory called vectors
switching into that directory.
This code firstly defines a macro, where a piece of code contains "SIZ 3" it will represent the function "add_vectors" which will accept three parameters for x, y and z (each being integer values).
This code inputs the xvec, yvec, and zvec, variables with the values 1,2,3 and 5,0,2 respectively and then adds the valuses together. It then checks the values are correct using the assert command. Of course, we know what the values "should" be by adding them together so we want the code to check that these values are correct. if they are not it will return an error.
Here we're including the vector.h file we created before so we can use SIZ again. We define a function called add_vectors and give it the parameters x y and z again. The for loop is the interesting part. We give it a variable called i and set it to 0 to start with. which refers to the first element of the zvec and states that as long as i is less than SIZ (which was defined to be 3) increment i by 1 which then changes i to represent 1 and then 2 and stops before 3. So the i value allows the for loop to add each term of the vectors in a loop. Beneath the for you can see that arithmetic operation using the i variable for the term in the array.
This command compiles the vector.c code. with the flags -Wall reporting and stopping if there are any errors and -pedantic making sure the code follows syntax rules.
We're adding the vector.o file to the library libvector.a.
Then we're compiling test_vector_add.c, linking it to libvector.a. NOTE: this is where I got up to before my work didn't save so from this point forward each line I'm executing for the first time and can predict what I think it might do beforehand. When I executed this line before it returned an error. This time I didn't get an error, and after executing it output nothing which means the vectors added as they should have (and the asserts found the values were correct).
Again adding the changes to git, committing the changes and then pushing them to the CSgitlab.
We're changing the assert for zvec to be 1 in the code here. This will break the code since zvec will take the 1st item of the array instead of the 2nd like it should so the assert won't be equal. And indeed it returned the error 'assertion 5==zvec[1] failed'.
Now we're adding to the define a dot product function which will similarly accept 3 parameters.
And also we're adding to the vector.c file a new function to multiply each item in the array for x and y using the same method as before, incrementing this i value.
And then we're creating a test file to check that the calculation worked properly using "assert"
Here we're recompiling vector.c since we've made changes to the code. I got a few errors here, most of them being syntax errors i.e. I forgot to put ";'s" in the right places or was missing spaces. But the more interesting error I got was that the types for dot_product were invalid. This was because in vector.h I typed in x, y and z into the parameters for the function when I actually only needed x and y. Removing int z[] in the function fixed this error.
and now we're adding the recompiled vector.o into the libvector.a library. The console said "r - vector.o" because we're actually replacing the existing vector.o that was created when we last compiled.
Then we're compiling the newly created test_vector_dot_product code. Again, a couple errors here, I used normal brackets instead of curly brackets and missed a ";". Fixing this resolved the errors.
And then executing the resulting executable. The console said nothing so the code must have worked.
And finally adding, committing and pushing the changes to git.
